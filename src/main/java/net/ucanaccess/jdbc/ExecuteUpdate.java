package net.ucanaccess.jdbc;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

public class ExecuteUpdate extends AbstractExecute {
    public ExecuteUpdate(UcanaccessPreparedStatement statement) {
        super(statement);
    }

    ExecuteUpdate(UcanaccessStatement statement) {
        super(statement);
    }

    public ExecuteUpdate(UcanaccessStatement statement, String sql) {
        super(statement, sql);
    }

    public ExecuteUpdate(UcanaccessStatement statement, String sql, int autoGeneratedKeys) {
        super(statement, sql, autoGeneratedKeys);
    }

    public ExecuteUpdate(UcanaccessStatement statement, String sql, int[] indexes) {
        super(statement, sql, indexes);
    }

    public ExecuteUpdate(UcanaccessStatement statement, String sql, String[] columnNames) {
        super(statement, sql, columnNames);
    }

    public int execute() throws SQLException {
        return (Integer) executeBase();
    }

    public int[] executeBatch() throws SQLException {
        this.commandType = CommandType.BATCH;
        return (int[]) executeBase();
    }

    @Override
    public Object executeWrapped() throws SQLException {
        Statement w = super.getWrappedStatement();
        switch (commandType) {
        case BATCH:
            return w.executeBatch();
        case PREPARED_STATEMENT:
            return ((PreparedStatement) w).executeUpdate();
        case NO_ARGUMENTS:
            return w.executeUpdate(sql);
        case WITH_COLUMNS_NAME:
            return w.executeUpdate(sql, columnNames);
        case WITH_AUTO_GENERATED_KEYS:
            return w.executeUpdate(sql, autoGeneratedKeys);
        case WITH_INDEXES:
            return w.executeUpdate(sql, indexes);
        default:
            return 0;
        }
    }
}
